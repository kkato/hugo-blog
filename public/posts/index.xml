<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on kkato.dev</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on kkato.dev</description>
    <image>
      <title>kkato.dev</title>
      <url>http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.140.0</generator>
    <language>en</language>
    <lastBuildDate>Thu, 05 Jun 2025 22:10:41 +0900</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Renovateの導入方法</title>
      <link>http://localhost:1313/posts/install-renovate/</link>
      <pubDate>Thu, 05 Jun 2025 22:10:41 +0900</pubDate>
      <guid>http://localhost:1313/posts/install-renovate/</guid>
      <description>&lt;p&gt;手動での依存パッケージのアップデートが大変だったので、&lt;a href=&#34;https://docs.renovatebot.com/&#34;&gt;Renovate&lt;/a&gt;を導入してみました。
その手順と設定について簡単にメモします。&lt;/p&gt;
&lt;h2 id=&#34;renovateとは&#34;&gt;Renovateとは？&lt;/h2&gt;
&lt;p&gt;Renovateは、依存関係の更新を自動化してくれるOSSのツールです。元々は個人開発から始まり、現在はイスラエルのセキュリティ企業 Mend社によって開発されています。&lt;/p&gt;
&lt;p&gt;リポジトリ内の依存関係をスキャンし、新しいバージョンが利用可能な場合には自動でPull Request（PR）を作成してくれます。
Node.jsのnpmやyarnはもちろん、Go modules、Docker、Terraformなど多くの言語やパッケージマネージャーに対応しているのも特徴です。&lt;/p&gt;
&lt;p&gt;対応しているパッケージマネージャーの一覧は&lt;a href=&#34;https://docs.renovatebot.com/modules/manager/#supported-managers&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;導入手順&#34;&gt;導入手順&lt;/h2&gt;
&lt;p&gt;renovateはセルフホストする方法とGitHub Appを使う方法の2通りありますが、今回はGitHub Appを使います。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apps/renovate&#34;&gt;https://github.com/apps/renovate&lt;/a&gt; から「Configure」を押す&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/install-renovate/configure.png&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;全てのリポジトリを選択し、導入する&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全てのリポジトリを選択したとしても、renovateの設定ファイルがあるリポジトリのみrenovateが有効になります。
そのため、renovateの設定ファイルがないリポジトリではrenovateが無効化されます。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/install-renovate/repository-access.png&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;renovateの設定ファイル&lt;code&gt;renovate.json&lt;/code&gt;を作成し、リポジトリのrootにpushする&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;各リポジトリで&lt;code&gt;Configure Renovate&lt;/code&gt;というPull Requestが自動的に作成されます。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/install-renovate/configure-renovate.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;自動生成された&lt;code&gt;renovate.json&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;$schema&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;https://docs.renovatebot.com/renovate-schema.json&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nt&#34;&gt;&amp;#34;extends&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;config:recommended&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;schema&#34;&gt;&lt;code&gt;$schema&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Renovateにおける&lt;code&gt;$schema&lt;/code&gt;は、&lt;code&gt;renovate.json&lt;/code&gt;で使える設定項目やその値の種類・ルールを定義しています。
これにより、どの設定が有効かをエディタが理解できたり、エディタによる補完などが有効になったりします。&lt;/p&gt;
&lt;h3 id=&#34;extends&#34;&gt;&lt;code&gt;extends&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;extends&lt;/code&gt;では、Renovateがあらかじめ用意しているルールセットを指定することができます。
上記の例では&lt;code&gt;config:recommended&lt;/code&gt;を指定しています。これには、どの言語やプロジェクトでも使える推奨設定が含まれています。
（以前は&lt;code&gt;config:recommended&lt;/code&gt;ではなく、&lt;code&gt;config:base&lt;/code&gt;と呼ばれていたみたいです。）&lt;/p&gt;
&lt;p&gt;詳しくは公式ドキュメントを参照してください: &lt;a href=&#34;https://docs.renovatebot.com/presets-config/#configrecommended&#34;&gt;https://docs.renovatebot.com/presets-config/#configrecommended&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;カスタム設定&#34;&gt;カスタム設定&lt;/h2&gt;
&lt;p&gt;詳しくは公式ドキュメントを参照してください: &lt;a href=&#34;https://docs.renovatebot.com/configuration-options/&#34;&gt;https://docs.renovatebot.com/configuration-options/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Install Cloudnativepg</title>
      <link>http://localhost:1313/posts/install-cloudnativepg/</link>
      <pubDate>Wed, 04 Jun 2025 22:08:59 +0900</pubDate>
      <guid>http://localhost:1313/posts/install-cloudnativepg/</guid>
      <description></description>
    </item>
    <item>
      <title>Postgres Operators</title>
      <link>http://localhost:1313/posts/postgres-operators/</link>
      <pubDate>Wed, 04 Jun 2025 22:08:44 +0900</pubDate>
      <guid>http://localhost:1313/posts/postgres-operators/</guid>
      <description></description>
    </item>
    <item>
      <title>ArgoCD Install</title>
      <link>http://localhost:1313/posts/install-argocd/</link>
      <pubDate>Tue, 06 May 2025 15:27:19 +0900</pubDate>
      <guid>http://localhost:1313/posts/install-argocd/</guid>
      <description></description>
    </item>
    <item>
      <title>PostgreSQL16をソースコードからビルドしてみる</title>
      <link>http://localhost:1313/posts/postgresql16-build/</link>
      <pubDate>Wed, 18 Sep 2024 14:47:07 +0900</pubDate>
      <guid>http://localhost:1313/posts/postgresql16-build/</guid>
      <description>&lt;p&gt;PostgreSQL16をソースコードからビルドしてみたのですが、いくつかつまづいたポイントがあるので、それらにご紹介します。&lt;/p&gt;
&lt;p&gt;PostgreSQL16をソースコードからビルドするためのコマンドは以下のとおりです。前提として M1 Mac (macOS 14.4.1) を使っています。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;% git clone git://git.postgresql.org/git/postgresql.git
% cd postgresql
% ./configure --enable-debug --enable-cassert --enable-tap-tests --prefix=$HOME/pgsql CFLAGS=-O0
% make -j 4
% make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;configureコマンドには以下のオプションを指定しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;デバッグしやすくするためのオプション: &amp;ndash;enable-debug &amp;ndash;enable-cassert &amp;ndash;enable-tap-tests&lt;/li&gt;
&lt;li&gt;インストール先のディレクトリを指定するオプション: &amp;ndash;prefix&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://www.postgresql.jp/document/16/html/install-make.html#CONFIGURE-OPTIONS&#34;&gt;https://www.postgresql.jp/document/16/html/install-make.html#CONFIGURE-OPTIONS&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;icu-uc-icu-i18nのパッケージが見つからない&#34;&gt;&lt;code&gt;icu-uc&lt;/code&gt;, &lt;code&gt;icu-i18n&lt;/code&gt;のパッケージが見つからない&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;icu-uc&lt;/code&gt;, &lt;code&gt;icu-i18n&lt;/code&gt;のパッケージが見つからないと言われました。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;% ./configure --enable-debug --enable-cassert --enable-tap-tests --prefix=$HOME/pgsql CFLAGS=-O0
(省略)
checking for icu-uc icu-i18n... no
configure: error: Package requirements (icu-uc icu-i18n) were not met:

No package &amp;#39;icu-uc&amp;#39; found
No package &amp;#39;icu-i18n&amp;#39; found

Consider adjusting the PKG_CONFIG_PATH environment variable if you
installed software in a non-standard prefix.

Alternatively, you may set the environment variables ICU_CFLAGS
and ICU_LIBS to avoid the need to call pkg-config.
See the pkg-config man page for more details.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PKG_CONFIG_PATHという環境変数を設定してあげれば良いみたいです。
以下のコマンドを実行すると、どう設定すればいいか教えてくれました。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Rocky Linuxにcontainerdをインストールする方法</title>
      <link>http://localhost:1313/posts/rocky-containerd/</link>
      <pubDate>Sun, 30 Jun 2024 16:46:03 +0900</pubDate>
      <guid>http://localhost:1313/posts/rocky-containerd/</guid>
      <description>&lt;p&gt;以前Kubernetesクラスタを構築するときに、Rocky Linuxでcontainerdをインストールする方法についてあまり情報がなかったので、とても苦労しました。
なので今回はその時に調べた内容を記事にしてみました。&lt;/p&gt;
&lt;p&gt;次のコマンドでcontainerdをインストールできます。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# yumにCentOS用のdockerリポジトリを追加する&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo yum config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# docker-ceリポジトリに含まれているcontainerd.ioのパッケージをインストールする&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo yum install -y containerd.io
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# containerdのデフォルト設定ファイルを生成する&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo sh -c &lt;span class=&#34;s2&#34;&gt;&amp;#34;containerd config default &amp;gt; /etc/containerd/config.toml&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;そして最後にcontainerdを有効化します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;systemctl &lt;span class=&#34;nb&#34;&gt;enable&lt;/span&gt; --now containerd.service
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@DannielWhatever/using-containerd-without-docker-9d08332781b4&#34;&gt;Using containerd without docker&lt;/a&gt; (Installing containerdの部分)&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>NUC上にk8sクラスタを構築する</title>
      <link>http://localhost:1313/posts/nuc-k8s/</link>
      <pubDate>Wed, 05 Jun 2024 21:20:47 +0900</pubDate>
      <guid>http://localhost:1313/posts/nuc-k8s/</guid>
      <description>&lt;p&gt;しばらく放置していたNUC上にk8sをインストールして、おうちクラスタを運用していこうと思います。
今回はkubeadmを使ってk8sをインストールしようと思います。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/nuc-k8s/nuc.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;前提&#34;&gt;前提&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ベアメタル(Intel NUC11PAHi5)上に構築&lt;/li&gt;
&lt;li&gt;Control Planex1台とWorkerx3台の4台構成&lt;/li&gt;
&lt;li&gt;OSはRocky Linux9.3&lt;/li&gt;
&lt;li&gt;ルーター側の設定で固定IPを割り当て&lt;/li&gt;
&lt;li&gt;各ノードのスペックは以下&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;CPU&lt;/th&gt;
          &lt;th&gt;メモリ&lt;/th&gt;
          &lt;th&gt;ストレージ&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;4コア&lt;/td&gt;
          &lt;td&gt;16GB&lt;/td&gt;
          &lt;td&gt;500GB&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;kubeadmのインストール&#34;&gt;kubeadmのインストール&lt;/h2&gt;
&lt;p&gt;以下の手順を参考にします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm/&#34;&gt;kubeadmのインストール&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;「始める前に」にSwapがオフであること、と記載がありますが、swapがオフになっていなかったので無効化します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo swapoff -a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;ポートの開放&#34;&gt;ポートの開放&lt;/h3&gt;
&lt;p&gt;kubernetesのコンポーネントが互いに通信するために、&lt;a href=&#34;https://kubernetes.io/docs/reference/networking/ports-and-protocols/&#34;&gt;これらのポート&lt;/a&gt;を開く必要があります。
RockyはRHEL系なので&lt;code&gt;firewall-cmd&lt;/code&gt;を使って、Control Planeノードのポートを開放します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo firewall-cmd --add-port=6443/tcp --permanent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo firewall-cmd --add-port=2379-2380/tcp --permanent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo firewall-cmd --add-port=10250/tcp --permanent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo firewall-cmd --add-port=10257/tcp --permanent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo firewall-cmd --add-port=10259/tcp --permanent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ポートが開放されたことを確認します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo firewall-cmd --reload
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo firewall-cmd --list-ports
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;続いて各Workerノードのポートを開放します。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-coonsole&#34; data-lang=&#34;coonsole&#34;&gt;sudo firewall-cmd --add-port=30000-32767/tcp --permanent
sudo firewall-cmd --add-port=10250/tcp --permanent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ポートが開放されたことを確認します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo firewall-cmd --reload
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;sudo firewall-cmd --list-ports
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;コンテナランタイムのインストール&#34;&gt;コンテナランタイムのインストール&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/ja/docs/setup/production-environment/container-runtimes/&#34;&gt;コンテナランタイム&lt;/a&gt;の手順を参考に、各ノードに設定をしていきます。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ウォンテッドリーに入社しました</title>
      <link>http://localhost:1313/posts/wantedly/</link>
      <pubDate>Tue, 06 Feb 2024 14:31:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/wantedly/</guid>
      <description>&lt;p&gt;ウォンテッドリーに入社して1ヶ月経ったので、色々と振り返ってみようと思います。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/wantedly/wantedly.jpeg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;転職を考えたきっかけ&#34;&gt;転職を考えたきっかけ&lt;/h2&gt;
&lt;p&gt;前職ではややニッチなテーマに取り組んでいたこともあり、そのまま長く居続けても他の会社でやっていけるか不安でした。また、変化が早い時代なので、会社に依存せず個人でやっていけるだけの実力・スキルを身につけたいと考え、もっと技術力を伸ばせるような会社に移りたいと思うようになりました。&lt;/p&gt;
&lt;h2 id=&#34;企業選びの軸&#34;&gt;企業選びの軸&lt;/h2&gt;
&lt;p&gt;企業選びは以下の軸をもとに考えました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自社でサービスを開発・運用している&lt;/li&gt;
&lt;li&gt;技術力の高いエンジニアが在籍している&lt;/li&gt;
&lt;li&gt;先進的な技術を扱っている&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記の条件を満たすような会社であれば、もっと技術力を伸ばせると思ったからです。&lt;/p&gt;
&lt;h2 id=&#34;転職に向けて行ったこと&#34;&gt;転職に向けて行ったこと&lt;/h2&gt;
&lt;p&gt;インフラエンジニア / SRE職を希望していたので、主に以下のようなことを行いました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;関連する資格の取得 (AWS SAP、CKA)&lt;/li&gt;
&lt;li&gt;個人ブログでの発信&lt;/li&gt;
&lt;li&gt;簡単なWebアプリの作成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前職でPostgreSQL、Kubernetesを触る機会があったものの、AWSやTerraformの経験、それに本番環境の運用経験がなく苦労しました。実務での経験不足を補うために、AWSの資格を取得したり、個人ブログで今まで学んだことのアウトプットなどを行うようにしました。また、SRE職などだと自動化のツールなどをGoで書くこともあると思ったので、Goで簡単なTo-doアプリを作成したりしました。&lt;/p&gt;
&lt;h2 id=&#34;ウォンテッドリーへの入社を決めた経緯&#34;&gt;ウォンテッドリーへの入社を決めた経緯&lt;/h2&gt;
&lt;p&gt;ウォンテッドリーへはスカウト経由で入社しました。（Wantedly Visitに登録したら、ウォンテッドリーからスカウトが来てびっくりしました笑）カジュアル面談で話を聞いていると、PostgreSQLやKubernetesなど今まで培った経験を活かしつつ、新しい挑戦ができそうだったので、選考を受けてみようと思いました。&lt;/p&gt;
&lt;p&gt;選考を受ける前だったか、1次面接の後だったか覚えていませんが、&lt;a href=&#34;https://docs.wantedly.dev/&#34;&gt;Engineering Handbook&lt;/a&gt;と&lt;a href=&#34;https://www.wantedly.com/companies/wantedly/post_articles/883691&#34;&gt;Culture Book&lt;/a&gt;をいただきました。まず、開発や会社の文化に関することがこのような形にまとめられているのが素敵だと思いました。そして、内容に関してもエンジニアリングに対して真摯に向き合う姿勢やエンジニアにとても理解のある会社だということが伝わってきて、こんな会社で働いてみたいと思うようになりました。（個人的にはCulture Bookの「変わるエンジニアの定義」が好きです。)&lt;/p&gt;
&lt;p&gt;また、2次選考として 1 day インターンに参加させていただきました。わずか1日のインターンシップではあるものの、チームメンバーがどんな人なのか、日々どんな業務に取り組んでいるのかなど実際に働くイメージがつき、その後安心して入社することができました。&lt;/p&gt;
&lt;h2 id=&#34;入社してからの感想&#34;&gt;入社してからの感想&lt;/h2&gt;
&lt;p&gt;毎日分からないことだらけですが、その分学ぶことが多くてとても充実しています。周りのエンジニアの方々は技術力が高くて、尊敬できる方ばかりです。&lt;/p&gt;
&lt;p&gt;オンボーディングに関しては、研修や社内のドキュメントが整備されていて、スムーズに環境に馴染むことができました。分からないことがあるとすぐに聞ける雰囲気があり、ちょっとしたことでもSlackやHuddleで相談できて大変ありがたいです。週2出社なので、対面でのコミュニケーションもできて良い感じです。&lt;/p&gt;
&lt;p&gt;びっくりしたことは、会議室の名前がジョジョの奇妙な冒険からつけられていること、白金台のランチの選択肢の少なさ、あとはエンジニアの1割がDvorak使いということですかね笑　&lt;/p&gt;
&lt;h2 id=&#34;今後ウォンテッドリーで取り組みたいこと&#34;&gt;今後ウォンテッドリーで取り組みたいこと&lt;/h2&gt;
&lt;p&gt;今後取り組みたいことは以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes, PostgreSQLなどのアップグレード&lt;/li&gt;
&lt;li&gt;インフラの性能監視・運用改善・障害対応&lt;/li&gt;
&lt;li&gt;Goを用いたツールの開発&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前職だと実運用を経験していなかったので、システム基盤のアップグレードを経験したいという思いがあります。同様に、性能監視や運用改善、障害対応などインフラエンジニアとして求められている基本的な業務も一通り経験してみたいです。また、ウォンテッドリーのインフラチームは様々なツールをGoで実装しているので、それらの実装を理解し改善していけるだけの力をつけていきたいです。&lt;/p&gt;
&lt;p&gt;上記以外にも直近不足している知識(NW、AWS、Terraform、Gitなど)が多いので、日々精進していく所存です！&lt;/p&gt;</description>
    </item>
    <item>
      <title>Alertmanagerのwebhookを試してみる</title>
      <link>http://localhost:1313/posts/webhook-nginx/</link>
      <pubDate>Sun, 13 Aug 2023 13:11:42 +0900</pubDate>
      <guid>http://localhost:1313/posts/webhook-nginx/</guid>
      <description>&lt;p&gt;Kubernetes上でAlertmanagerがちゃんと通知できるか、どんな内容が通知されているのか確認してみようとすると、連携するためのSlackが必要であったり、Emailを送信するにもメールサーバが必要だったりと、意外と気軽に試せないということがありました。&lt;/p&gt;
&lt;p&gt;なので、今回はwebhookの機能を使ってNginxにリクエストを飛ばし、リクエストの内容をログから確認してみようと思います。&lt;/p&gt;
&lt;h2 id=&#34;webhookとは&#34;&gt;webhookとは?&lt;/h2&gt;
&lt;p&gt;Alertmanagerのreceiverには以下が指定できます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Email&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.atlassian.com/software/opsgenie&#34;&gt;Opesgenie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pagerduty.com/&#34;&gt;PagerDuty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pushover.net/&#34;&gt;Pushover&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://slack.com/intl/ja-jp&#34;&gt;Slack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/sns/&#34;&gt;AWS SNS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.splunk.com/en_us/about-splunk/acquisitions/splunk-on-call.html&#34;&gt;VictorOps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Webhook&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.wechat.com/ja/&#34;&gt;Wechat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://telegram.org/&#34;&gt;Telegram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.webex.com/ja/index.html&#34;&gt;Webex&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Webhookとは特定のエンドポイントに対してHTTP POSTリクエストでアラートの情報を送信するというものです。
外部サービスではないので、自分自身でエンドポイントを用意し、自分自身で後続の処理を実装する必要があります。&lt;/p&gt;
&lt;p&gt;例えば、以下のように設定します。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;receivers:
- name: &amp;#34;nginx&amp;#34;
  webhook_configs:
  - url: &amp;#39;http://nginx-svc.default:8080/&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;webhookの連携先としてnginxを使う&#34;&gt;webhookの連携先としてnginxを使う&lt;/h2&gt;
&lt;p&gt;今回はwebhookの連携先としてnginxを使用します。&lt;/p&gt;
&lt;p&gt;nginxを使って実現したいことは以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;エンドポイントを用意する&lt;/li&gt;
&lt;li&gt;リクエスト内容を確認する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;nginx.confの初期設定をベースにしていますが、そのままだとリクエスト内容を確認することができないので、設定を追加しました。
&lt;code&gt;log_format&lt;/code&gt;で&lt;code&gt;$request_body&lt;/code&gt;を指定し、&lt;code&gt;/&lt;/code&gt;にアクセスした時に&lt;code&gt;$request_body&lt;/code&gt;がログとして標準出力に出るように設定しています。&lt;/p&gt;
&lt;p&gt;しかし、&lt;code&gt;$request_body&lt;/code&gt;を有効化するには&lt;code&gt;proxy_pass&lt;/code&gt;などの後続処理が必要になります。なので、&lt;code&gt;proxy_pass&lt;/code&gt;で&lt;code&gt;/trash&lt;/code&gt;というエンドポイントにリクエストを転送し、&lt;code&gt;/trash&lt;/code&gt;で特に意味のない処理(1x1ピクセルのgifを返す)をしています。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The variable’s value is made available in locations processed by the proxy_pass, fastcgi_pass, uwsgi_pass, and scgi_pass directives when the request body was read to a memory buffer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body&#34;&gt;http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body&lt;/a&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  &amp;#39;$remote_addr - $remote_user [$time_local] &amp;#34;$request&amp;#34; &amp;#39;
                      &amp;#39;$status $body_bytes_sent &amp;#34;$http_referer&amp;#34; &amp;#39;
                      &amp;#39;&amp;#34;$http_user_agent&amp;#34; &amp;#34;$http_x_forwarded_for&amp;#34;&amp;#39;;

    access_log  /var/log/nginx/access.log  main;

    # -------------------追加設定---------------------
    log_format  postdata escape=none $request_body;

    server {
        listen   8080;
        location / {
            access_log /dev/stdout postdata;
            proxy_pass http://127.0.0.1:8080/trash;
        }
        location /trash {
            access_log off;
            empty_gif;
            break;
        }
    }
    # ----------------------------------------------

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上記の設定をConfigMapとして作成し、nginxのPodに対してConfigMapをマウントしてあげます。&lt;code&gt;nginx-svc&lt;/code&gt;というServiceも作成します。&lt;/p&gt;</description>
    </item>
    <item>
      <title>KubernetesのCronJobが失敗したときにアラートをあげる</title>
      <link>http://localhost:1313/posts/k8s-job-alert/</link>
      <pubDate>Tue, 08 Aug 2023 19:48:39 +0900</pubDate>
      <guid>http://localhost:1313/posts/k8s-job-alert/</guid>
      <description>&lt;p&gt;CronJobは、指定したcronフォーマットに基づいて定期的にJobを実行するという機能です。
主にバックアップの取得やメール送信など、定期的な処理を実行する際に便利です。&lt;/p&gt;
&lt;p&gt;一方で、CronJobが失敗した際にどのように検知すべきかについては、あまり情報がありませんでした。
なので、今回はそちらについて考えてみたいと思います。&lt;/p&gt;
&lt;h2 id=&#34;kube-state-metricsを活用する&#34;&gt;kube-state-metricsを活用する&lt;/h2&gt;
&lt;p&gt;kube-state-metricsとはKubernetesクラスタ内のリソースの状態をメトリクスとして提供してくれるというものです。
kube-state-metricsではCronJobやJobの状態をメトリクスとして取得することができます。
この方式採用している記事が多かったので、こちらで検討を進めてみたいと思います。&lt;/p&gt;
&lt;p&gt;※記事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@tristan_96324/prometheus-k8s-cronjob-alerts-94bee7b90511&#34;&gt;https://medium.com/@tristan_96324/prometheus-k8s-cronjob-alerts-94bee7b90511&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.giffgaff.io/tech/monitoring-kubernetes-jobs&#34;&gt;https://www.giffgaff.io/tech/monitoring-kubernetes-jobs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;どのメトリクスを使い監視するか&#34;&gt;どのメトリクスを使い監視するか&lt;/h2&gt;
&lt;p&gt;CronJobはcronフォーマットで指定された時刻にJobを生成し、そのJobがPodを生成するという3層の親子構造になっています。
また、CronJobとJobの関係は1対多で、JobとPodの関係は1対多になります。&lt;/p&gt;
&lt;p&gt;Jobが完了するのは&lt;code&gt;completions&lt;/code&gt;個のPodが正常終了した場合、もしくは&lt;code&gt;backoffLimit&lt;/code&gt;個のPodが異常終了した場合に限ります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;completions
&lt;ul&gt;
&lt;li&gt;completions個のPodが成功すると、Jobが完了したとみなされる&lt;/li&gt;
&lt;li&gt;デフォルトは1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;backoffLimit
&lt;ul&gt;
&lt;li&gt;失敗したと判断するまでの再試行回数で、この回数を超えるとJobは失敗とみなされる&lt;/li&gt;
&lt;li&gt;デフォルトは6&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;そして、アラートを上げたいのはJobが失敗した時です。言い換えると、&lt;code&gt;backoffLimit&lt;/code&gt;個のPodが異常終了したときにアラートを上げるということになります。
何個のPodが異常終了したのか監視することも可能だと思いますが、ここではJobのステータスを監視するのが適切かと思います。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;メトリクス&lt;/th&gt;
          &lt;th&gt;対応する項目&lt;/th&gt;
          &lt;th&gt;説明&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;kube_job_status_succeeded&lt;/td&gt;
          &lt;td&gt;.status.succeeded&lt;/td&gt;
          &lt;td&gt;Jobの管理下で正常終了したPodの数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;kube_job_status_failed&lt;/td&gt;
          &lt;td&gt;.status.failed&lt;/td&gt;
          &lt;td&gt;Jobの管理下で異常終了したPodの数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;kube_job_complete&lt;/td&gt;
          &lt;td&gt;.status.conditions.type&lt;/td&gt;
          &lt;td&gt;Jobが成功したかどうか&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;kube_job_failed&lt;/td&gt;
          &lt;td&gt;.status.conditions.type&lt;/td&gt;
          &lt;td&gt;Jobが失敗したかどうか&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://github.com/kubernetes/kube-state-metrics/blob/main/docs/job-metrics.md&#34;&gt;https://github.com/kubernetes/kube-state-metrics/blob/main/docs/job-metrics.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Jobに関するメトリクスは複数ありますが、この中でも特に&lt;code&gt;kube_job_failed&lt;/code&gt;を使ってアラートを上げるのが良さそうです。
以下の設定だと、Jobが失敗したときにアラートが上がります。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kube_job_failed &amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;アラートが発火し続けてしまう問題&#34;&gt;アラートが発火し続けてしまう問題&lt;/h2&gt;
&lt;p&gt;失敗したJobは削除されずに残り続けるので、アラートが発火し続けてしまいます。
なので、Jobの&lt;code&gt;ttlSecondsAfterFinished&lt;/code&gt;を設定し、数分後にJobが削除されるようにします。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ttlSecondsAfterFinished
&lt;ul&gt;
&lt;li&gt;指定秒後にJobを削除できる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CronJobの&lt;code&gt;failedJobsHistoryLimit&lt;/code&gt;を設定するという方法も思いつきましたが、0にしてしまうとそもそもアラートが上がらないと思うので、こちらは1のままにしておきました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;failedJobsHistoryLimit
&lt;ul&gt;
&lt;li&gt;失敗したJobを指定個数分残しておける&lt;/li&gt;
&lt;li&gt;デフォルトは1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;今回はkube-state-metricsを活用して、CronJobが失敗した時のアラートを設定しました。CronJob失敗時にアラートを上げる方法についてはあまり参考になる記事がなく、私なりに考えてみました。他にもっといい方法をご存知の方は教えていただけるとありがたいです。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linuxで公開鍵認証をする</title>
      <link>http://localhost:1313/posts/pubkey-auth/</link>
      <pubDate>Wed, 12 Jul 2023 21:23:52 +0900</pubDate>
      <guid>http://localhost:1313/posts/pubkey-auth/</guid>
      <description>&lt;p&gt;Linuxでの公開鍵認証の設定をよく忘れてしまうので、備忘録としてメモを残しておきます。&lt;/p&gt;
&lt;h2 id=&#34;接続元での設定&#34;&gt;接続元での設定&lt;/h2&gt;
&lt;p&gt;接続元で鍵を生成し、公開鍵を接続先のサーバーへコピーします。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ssh-keygen
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;scp ~/id_rsa.pub username@server:~/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;接続先の設定&#34;&gt;接続先の設定&lt;/h2&gt;
&lt;p&gt;接続先のサーバーで公開鍵の情報をauthorized_keysに登録し、適切な権限を設定します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir ~/.ssh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;chmod &lt;span class=&#34;m&#34;&gt;700&lt;/span&gt; ~/.ssh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cat id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;chmod &lt;span class=&#34;m&#34;&gt;600&lt;/span&gt; ~/.ssh/authorized_keys
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;公開鍵認証を有効化し、パスワード認証を無効化します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo vi /etc/ssh/sshd_config
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PubkeyAuthentication yes
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PasswordAuthentication no
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;sshdを再起動します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;systemctl restart sshd
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>kubesprayでk8sクラスタを構築する</title>
      <link>http://localhost:1313/posts/kubespray/</link>
      <pubDate>Mon, 01 May 2023 10:07:31 +0900</pubDate>
      <guid>http://localhost:1313/posts/kubespray/</guid>
      <description>&lt;p&gt;k8s構築ツールはいろいろありますが、公式ドキュメントでは以下が紹介されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/ja/docs/setup/learning-environment/&#34;&gt;学習環境&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Minikube&lt;/li&gt;
&lt;li&gt;Kind&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kubernetes.io/ja/docs/setup/production-environment/&#34;&gt;プロダクション環境&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;kubeadm&lt;/li&gt;
&lt;li&gt;kops&lt;/li&gt;
&lt;li&gt;kubespray&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;※各ツールの違いについては&lt;a href=&#34;https://github.com/kubernetes-sigs/kubespray/blob/master/docs/comparisons.md&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今回はその中でも&lt;a href=&#34;https://github.com/kubernetes-sigs/kubespray&#34;&gt;kubespray&lt;/a&gt;というツールを使ってk8sクラスタを構築してみようと思います。kubeadmは1台ずつインストールを実施するのに対し、kubesprayはAnsibleを使い、各ノードで一斉にインストールを実施します。なので、kubesprayは台数が多いときに便利です。&lt;/p&gt;
&lt;p&gt;ちなみに、kubesprayは内部でkubeadmを使っているので、kubespray = kubeadm + Ansibleという感じです。また、kubesprayを使うと、コンテナランタイム(デフォルトはcontainerd)やPod間通信のネットワークプラグイン(デフォルトはcalico)などが自動でインストールされるので、非常に便利です。&lt;/p&gt;
&lt;h2 id=&#34;構築&#34;&gt;構築&lt;/h2&gt;
&lt;p&gt;前提:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ベアメタル(Intel NUC11PAHi5)上に構築&lt;/li&gt;
&lt;li&gt;Control Planex1台とWorkerx3台の4台構成&lt;/li&gt;
&lt;li&gt;OSはRocky Linux9.1&lt;/li&gt;
&lt;li&gt;ルーター側の設定で固定IPを割り当て&lt;/li&gt;
&lt;li&gt;各ノードのスペックは以下&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;CPU&lt;/th&gt;
          &lt;th&gt;メモリ&lt;/th&gt;
          &lt;th&gt;ストレージ&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;4コア&lt;/td&gt;
          &lt;td&gt;16GB&lt;/td&gt;
          &lt;td&gt;500GB&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ssh公開認証の設定&#34;&gt;ssh公開認証の設定&lt;/h3&gt;
&lt;p&gt;手元のPCからパスワードなしでssh接続できるように公開鍵認証の設定をします。
ssh-keygenのパスワードには空文字を指定します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kkato@bastion:~$ ssh-keygen
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kkato@bastion:~$ scp ~/.ssh/id_rsa.pub 192.168.10.xxx:~/
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;公開鍵の情報を各ノードのauthorized_keysに追記します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kkato@nuc01:~$ mkdir ~/.ssh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kkato@nuc01:~$ chmod &lt;span class=&#34;m&#34;&gt;700&lt;/span&gt; /.ssh
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kkato@nuc01:~$ cat id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kkato@nuc01:~$ chmod &lt;span class=&#34;m&#34;&gt;600&lt;/span&gt; ~/.ssh/authorized_keys
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;etchostsの編集&#34;&gt;/etc/hostsの編集&lt;/h3&gt;
&lt;p&gt;手元のPCから各ノードへホスト名で接続できるように、/etc/hostsを編集します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kkato@bastion:~$ cat /etc/hosts
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;192.168.10.121 nuc01
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;192.168.10.122 nuc02
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;192.168.10.123 nuc03
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;192.168.10.124 nuc04
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;ユーザーの設定&#34;&gt;ユーザーの設定&lt;/h3&gt;
&lt;p&gt;各ノードのユーザーがパスワードなしでsudo実行できるよう設定します。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Raspberry Pi上にk8sクラスタを構築する</title>
      <link>http://localhost:1313/posts/raspi-k8s/</link>
      <pubDate>Sun, 23 Apr 2023 16:13:42 +0900</pubDate>
      <guid>http://localhost:1313/posts/raspi-k8s/</guid>
      <description>&lt;p&gt;最近ラズパイを手に入れたので、kubeadmを使ってk8sクラスタを組んでみたいと思います。
Control Planeノードx1 Workerノードx3の構成です。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/raspi-k8s/raspi-cluster.jpg&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;準備&#34;&gt;準備&lt;/h2&gt;
&lt;p&gt;準備したものは以下のとおりです。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;アイテム&lt;/th&gt;
          &lt;th&gt;個数&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.switch-science.com/products/5680&#34;&gt;Raspberry Pi 4 Model B / 4GB&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://www.switch-science.com/products/7172?_pos=1&amp;amp;_sid=e013ece27&amp;amp;_ss=r&#34;&gt;Raspberry Pi PoE+ HAT&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://amzn.asia/d/8DQ2Vjn&#34;&gt;ケース&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://amzn.asia/d/1a7lXpn&#34;&gt;microSD 64GB&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://amzn.asia/d/6lrvPog&#34;&gt;スイッチングハブ&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://amzn.asia/d/cSs0irO&#34;&gt;LANケーブル 0.15m&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;4&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://amzn.asia/d/0IejUmF&#34;&gt;LANケーブル 1m&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://amzn.asia/d/4oTN3E9&#34;&gt;SDカードリーダー&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;a href=&#34;https://amzn.asia/d/a8TZ1OH&#34;&gt;HDMI変換アダプター&lt;/a&gt;&lt;/td&gt;
          &lt;td&gt;1&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;PoE(Power over Ethernet)+ HATを使うと、LANケーブルから電源供給できるのでとても便利です。今回はPoE+ HATを使っているので、スイッチングハブもPoE対応のものを購入しています。ラズパイのOSをSDカードにインストールする必要があるので、SDカードリーダーも購入しました。あとは、ディスプレイと繋ぐときにmicro HDMIに変換するためのアダプタも購入しました。&lt;/p&gt;
&lt;h2 id=&#34;osの設定&#34;&gt;OSの設定&lt;/h2&gt;
&lt;h3 id=&#34;osのインストール&#34;&gt;OSのインストール&lt;/h3&gt;
&lt;p&gt;手元のPCはUbuntu 22.04 LTSなので、以下のコマンドでRaspberry Pi Imagerをインストールします。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ sudo apt install rpi-imager
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;そして、microSDカード4枚全てにUbuntu Server 22.10 (64-bit)を焼きます。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ rpi-imager
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/raspi-k8s/raspi-imager.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;microSDカードを差し込み、ディスプレイ(micro HDMI)とキーボード(USB)を接続し、OSの初期設定を行います。初期ユーザー名とパスワードはubuntuです。パッケージを最新にしておきます。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo spy update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ sudo apt upgrade -y
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;新しくユーザを作成し、ユーザにsudo権限を付与します。sudoをパスワードなしでできるように追加の設定もします。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ジョージア工科大学 OMSCSを振り返って</title>
      <link>http://localhost:1313/posts/omscentral/</link>
      <pubDate>Mon, 10 Apr 2023 18:05:06 +0900</pubDate>
      <guid>http://localhost:1313/posts/omscentral/</guid>
      <description>&lt;p&gt;2020年8月にジョージア工科大学 コンピューターサイエンス修士課程(通称OMSCS)に入学し、2022年12月に卒業しました。今回は入学から卒業までを振り返ってみようと思います。&lt;/p&gt;
&lt;h2 id=&#34;なぜomscsを始めたのか&#34;&gt;なぜOMSCSを始めたのか&lt;/h2&gt;
&lt;p&gt;実は途中でOMSAからOMSCSに編入していたりしますが、OMSCSを始めた主な目的は以下です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;専門的な知識を身につける&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;私は物理学の学士課程を卒業していますが、物理を学ぶと選択肢は広がるものの少し中途半端なんですよね。例えば、機械系に行きたいとすると機械工学の学生でいいじゃん、電子系に行きたいとすると電子工学の学生でいいじゃん、IT系に行きたいとすると情報系の学生でいいじゃん、となってしまいます。なので、物理学＋αでより専門的な知識を身につけて、今後のキャリアアップに役立てたいと考えました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;海外で就職する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実は私はカナダの大学で学士号を取得していますが、卒業当時の私は現地就職するだけの自信と実力がありませんでした。国際的に評価されている大学の修士号であれば、海外で就職するときもプラスに働くと思い、OMSCSを始めることにしました。&lt;/p&gt;
&lt;h2 id=&#34;実際どうだったか&#34;&gt;実際どうだったか&lt;/h2&gt;
&lt;p&gt;正直かなり大変でした。コロナで家にいる時間も多かったですが、平日の仕事終わりと週末は基本的に家でずっと勉強していました。遊びに誘われることもありましたが、毎回断っていたら誰からも誘われなくなりました笑&lt;/p&gt;
&lt;p&gt;どれくらいの時間が必要かというと、前提知識があるかどうかにもよると思いますが、1コースにつき週10-20時間は必要だと思います。ちなみに私は基本的に1学期に2コース取っていたので、休む時間がほとんどありませんでした。&lt;/p&gt;
&lt;p&gt;また、卒業には以下の条件があり、良い成績をとらないと卒業できないというプレッシャーがありました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最初の12ヶ月でfundamental courseを最低2つ履修し、B以上の成績を収めなければならない&lt;/li&gt;
&lt;li&gt;専門分野のコースは全てB以上の成績を収めなければならない&lt;/li&gt;
&lt;li&gt;合計GPAが3.0/4.0以上でなければならない&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;どんな授業を受けたのか&#34;&gt;どんな授業を受けたのか&lt;/h2&gt;
&lt;p&gt;OMSCSではSpecialization&lt;a href=&#34;#%E5%8F%82%E8%80%83&#34;&gt;*1&lt;/a&gt;といって専門分野を決める必要があるのですが、私はComputing Systemsにしました。その理由としては配属された部署がデータベースや分散システムなどのミドルウェアを扱うところだったから、また低レイヤーの技術に興味があったからです。OMSCSでは10コース履修する必要がありますが、そのうち5, 6コースを自分の専門分野から履修しなければなりません(いわゆる必修科目)。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;学期&lt;/th&gt;
          &lt;th&gt;受講したコース&lt;/th&gt;
          &lt;th&gt;難易度&lt;/th&gt;
          &lt;th&gt;作業量&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Fall 2020&lt;/td&gt;
          &lt;td&gt;CSE6040 Computing for Data Anlysis&lt;/td&gt;
          &lt;td&gt;易しい&lt;/td&gt;
          &lt;td&gt;10時間/週&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Fall 2020&lt;/td&gt;
          &lt;td&gt;ISYE6501 Introduction to Analytics Modeling&lt;/td&gt;
          &lt;td&gt;普通&lt;/td&gt;
          &lt;td&gt;15時間/週&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Summer 2021&lt;/td&gt;
          &lt;td&gt;CS6300 Software Development Process&lt;/td&gt;
          &lt;td&gt;普通&lt;/td&gt;
          &lt;td&gt;10時間/週&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Fall 2021&lt;/td&gt;
          &lt;td&gt;CS6250 Computer Networks&lt;/td&gt;
          &lt;td&gt;普通&lt;/td&gt;
          &lt;td&gt;10時間/週&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Fall 2021&lt;/td&gt;
          &lt;td&gt;CS7646 Machine Learning for Trading&lt;/td&gt;
          &lt;td&gt;普通&lt;/td&gt;
          &lt;td&gt;15時間/週&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Spring 2022&lt;/td&gt;
          &lt;td&gt;CS6035 Introduction to Information Security&lt;/td&gt;
          &lt;td&gt;普通&lt;/td&gt;
          &lt;td&gt;15時間/週&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Spring 2022&lt;/td&gt;
          &lt;td&gt;CS6200 Introduction to Operating Systems&lt;/td&gt;
          &lt;td&gt;難しい&lt;/td&gt;
          &lt;td&gt;20時間/週&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Summer 2022&lt;/td&gt;
          &lt;td&gt;CS6262 Network Security&lt;/td&gt;
          &lt;td&gt;普通&lt;/td&gt;
          &lt;td&gt;15時間/週&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Fall 2022&lt;/td&gt;
          &lt;td&gt;CS6515 Introduction to Graduate Algorithms&lt;/td&gt;
          &lt;td&gt;難しい&lt;/td&gt;
          &lt;td&gt;15時間/週&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Fall 2022&lt;/td&gt;
          &lt;td&gt;CS9903-O13 Quantum Computing&lt;/td&gt;
          &lt;td&gt;易しい&lt;/td&gt;
          &lt;td&gt;10時間/週&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;受講したコースについて少し紹介しようと思います。2023年現在、OMSCSでは61コース提供されており&lt;a href=&#34;#%E5%8F%82%E8%80%83&#34;&gt;*2&lt;/a&gt;、定期的に追加・更新されます。また、OMSCSにはOMSCentral&lt;a href=&#34;#%E5%8F%82%E8%80%83&#34;&gt;*3&lt;/a&gt;という非公式のレビューサイトがあるので、そちらも参考にしてみてください。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ジョージア工科大学 OMSCSへの出願方法</title>
      <link>http://localhost:1313/posts/omscs/</link>
      <pubDate>Tue, 21 Mar 2023 18:04:49 +0900</pubDate>
      <guid>http://localhost:1313/posts/omscs/</guid>
      <description>&lt;p&gt;ジョージア工科大学 コンピューターサイエンス修士課程(通称OMSCS)の概要とその出願方法について紹介します。&lt;/p&gt;
&lt;h2 id=&#34;omscsとは&#34;&gt;OMSCSとは&lt;/h2&gt;
&lt;p&gt;Online Master of Science in Computer Science (OMSCS)はアメリカの州立大学であるジョージア工科大学が提供しているプログラムになります。&lt;/p&gt;
&lt;p&gt;このプログラムの特徴としては以下が挙げられます&lt;a href=&#34;#%E5%8F%82%E8%80%83&#34;&gt;*1&lt;/a&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全てオンラインで完結すること&lt;/li&gt;
&lt;li&gt;学費が安いこと&lt;/li&gt;
&lt;li&gt;オンキャンパスと同等の学位であること&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;近年、MOOCなどオンラインで取得できる学位プログラムは増えつつありますが、OMSCSは2014に開始され、オンラインの学位プログラムとしては先駆け的な存在です。また、OMSCSは学費が安いことを売りにしており、オバマ元大統領も言及しています&lt;a href=&#34;#%E5%8F%82%E8%80%83&#34;&gt;*2&lt;/a&gt;。そして、OMSCSはオンラインの学位とオンキャンパスの学位を区別せず、同等の学位として扱います。卒業証書には&amp;quot;Master of Science in Computer Science&amp;quot;と記載されます。&lt;/p&gt;
&lt;p&gt;実際に私が支払った金額を参考までに載せておきます。(Spring 2021は諸々の事情により、学期の途中から休学することにしました。)&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;学期&lt;/th&gt;
          &lt;th&gt;米ドル&lt;/th&gt;
          &lt;th&gt;日本円&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Fall 2020&lt;/td&gt;
          &lt;td&gt;$1951&lt;/td&gt;
          &lt;td&gt;21万円&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Spring 2021&lt;/td&gt;
          &lt;td&gt;$455&lt;/td&gt;
          &lt;td&gt;5万円&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Summer 2021&lt;/td&gt;
          &lt;td&gt;$841&lt;/td&gt;
          &lt;td&gt;9万円&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Fall 2021&lt;/td&gt;
          &lt;td&gt;$1381&lt;/td&gt;
          &lt;td&gt;16万円&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Spring 2022&lt;/td&gt;
          &lt;td&gt;$1341&lt;/td&gt;
          &lt;td&gt;17万円&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Summer 2022&lt;/td&gt;
          &lt;td&gt;$841&lt;/td&gt;
          &lt;td&gt;11万円&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Fall 2022&lt;/td&gt;
          &lt;td&gt;$1187&lt;/td&gt;
          &lt;td&gt;17万円&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;合計&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;$8037&lt;/td&gt;
          &lt;td&gt;96万円&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;最近ではOMSCS以外にもOnline Master of Science in Analytics (OMSA)やOnline Master of Science in Cybersecurity (OMS Cybersecurity)などのプログラムが提供されています。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
